# Barton's Phase 8 "Grand Expansion" Retrospective Contribution

**What went well on Track A and D**

Track A shipped clean on the data side. Sentinel Coif fix was straightforward — mismatched defense bonus in the JSON, corrected at source. The 4-piece set bonus wiring integrated without friction: we added stat modifiers to the armor class, checked set membership in InventoryManager.EquipItem(), applied bonuses on equip and removed them on unequip. No duplicate state, no special cases. Epic loot tier was a pure data-driven addition (new Item objects in the loot table, new rarity flag in ItemStats JSON) with corresponding display feedback. Armor slot tests covered the happy paths and edge cases (equipping/unequipping swaps, bonus stacking, set breakage). Track D's status effects and trap rooms shipped as modular systems—Freeze/Silence/Curse followed the established StatusEffectManager pattern (duration tracking, damage-per-turn calculations), and the three trap variants (spike floors, arrow corridors, pressure plate hallways) integrated into RoomContent as data-driven encounter modifiers without touching core combat or pathfinding.

**What was painful**

CombatEngine.cs became a merge bottleneck. Five PRs touched that file (A2 set bonuses, B2 boss phase, B3 narration, C2 class passives, D3 environmental hazards), and each one created conflicts that weren't just whitespace. Rebase order mattered. We had to land A2 first, then D3, then B2, then C2, then B3—the sequence wasn't obvious upfront and we rebased twice. The duplicate forward-reference issue between C2 and B3 was a process failure: C2 added ResetCombatPassives() and passive state fields to Player.cs; B3 had stubbed the same fields in PlayerCombat.cs as a forward-ref; both agents didn't coordinate the touch points, so we got duplicate member errors on three consecutive commits until a hotfix removed B3's stub. The bigger issue was invisible—B3 ran for 21+ minutes and timed out multiple times, and it generated competing branches that overlapped with B2's work. We also manually closed 19 orphaned open issues from duplicate agent runs (Wave 1 agents 25-28, then Wave 2 agents 29-37 both ran, both created PRs, both left issues open). The squash merge workflow doesn't auto-close issues from "Closes #N" in the PR body, so issues stayed open even after PRs merged. That required manual cleanup that could have been prevented.

**Concrete process improvement proposals**

1. **CombatEngine.cs code ownership assignment** — Assign explicit owners to high-touch files before agent dispatch. Create a touch-point registry: A2 owns equipment wiring (armor apply/remove logic), B2 owns turn execution, C2 owns passive initialization, D3 owns trap application, B3 owns narration output. If an agent's task overlaps another owner's area, coordinate PR sequencing or have them comment on each other's branches before merge.

2. **Agent deduplication and wave management** — Establish a single agent run per phase. If an agent session times out, either extend initial_wait or restart in a fresh session with explicit dependency notes (don't re-run Wave 1). Use a shared checklist in .ai-team/decisions.md to track which agent IDs are active and which are complete. This prevents the "both waves running in parallel" issue.

3. **Forward-reference stub protocol** — Any code that stubs fields for future PRs must be marked with a TODO comment and added to a shared stub registry (e.g., `.ai-team/stubs-in-progress.md`). Before merge, verify no other PR has already implemented that stub. If B3 had checked the registry and seen that C2 was implementing ResetCombatPassives(), they would have skipped their forward-ref and just called the real C2 method.

4. **Issue auto-close on squash merge** — Add a post-merge automation: squash merge PRs should check their body for "Closes #N" patterns and call `gh issue close #N` as a separate step. Or switch to rebase+merge for high-touch PRs (preserves individual commits, still closes issues automatically). Squash is fine for cleanup PRs (phase-end refactoring), but not for feature PRs that define future work.

5. **Build on Phase 7 action items** — Complete the MerchantSystem spike from Phase 7 before Phase 9. We have armor/consumable data structures now; Merchant just needs buy/sell/barter state machines and inventory limits. Equip-protection warning (don't sell equipped items) should be part of that spike. Extract command handlers from GameLoop.cs in parallel—GameLoop is growing again, same problem as CombatEngine. ASCII art implementation is feasible and greenlit; scope it as a Phase 9 stretch goal (data-driven approach means content work doesn't block anything).
